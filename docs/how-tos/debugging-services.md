# Debugging components in local environment

## Introduction

The major use case for a local environment is to debug services you develop while running other dependencies seamlessly. Great deal of thought had been put into making that possible with locally - you should be able to start/stop containers, run code in a debugger, run (and debug!) integration tests locally. The latter is a big deal - before you could only do that against a real environment, potentially used by others.

Default locally behavior is based on [Pipelines](../pipelines.md) concept, which is a way to package services as _third party_ - meaning locally downloads an image for the service from the container registry and runs that in your local Docker instance. This approach greatly simplifies running any dependencies you need with as little work as possible (especially with pipelines for all services being pre-created and made available). It is recommended to rely on this approach for anything you are not actively developing.

### Debugging a service

### How to find parameters for a service running locally

When locally creates and runs a component, behind the scene it creates a `docker-compose.yml` file for each of them. All auto-generated files are located in `.locally` subdirectory in the root of your context directory tree, with `docker_compose` directory there holding all of docker-compose files for all components that locally knows about:

```ascii
locally/
├─ contexts/
│  ├─ local/
│  │  ├─ .locally/
│  │  │  ├─ docker_compose/
│  │  │  |  ├─ config-service/
│  │  │  |  |  ├─ docker-compose.yaml
│  │  ├─ services/
│  │  │  ├─ backends/
│  │  │  |  ├─ config_service.yml
│  │  │  ├─ infrastructure/
│  │  │  ├─ mocks/
│  │  │  ├─ pipelines/
│  │  │  ├─ tenants/
│  │  │  ├─ webclients/
│  │  ├─ context-config.yml
├─ locally-config.yml
├─ locally.exe
```

The `docker-compose.yml` file acts as a container for all attributes of a Docker image that needs to be run. You can always refer to these files to observe which parameters services get initialized and run with.

### Start debugging

Debugging a service is pretty straightforward - instead of running a service in a container you instead run it in a debugger. Here are the step-by-step instructions:

- Make sure to collect all of the configuration (environment variables, ports, connection strings, etc.) from the `docker_compose.yaml` or `docker-compose.override.yml` file generated by locally for this particular component (see the directory structure above)
- All of the configuration collected needs to be carried over into your debugger of choice - open the source code project(s) and configure the debugger with all values from the first step
- Stop the component's container created by locally (below we're stopping a `config-service-proxy` component from `config-service` service definition)
  
  ```bash
  locally docker stop config-service config-service-proxy
  ```

  - In case the service in question accepts HTTP communication - the calls to it will start failing with 502 errors. However Caddy's proxy that points to the stopped container is still active - we haven't stopped Caddy or changed its configuration
- Build and run the component from within your debugger (Visual Studio for .NET)
  - You did remember to carry over all of the configuration parameters, right?
- Since the code in debugger runs with all locally provided configurations, it will act exactly the same as the containerized version - HTTP requests will be arriving at the instance being debugged, Service Bus messages will be picked up and processed there, etc.
  - Caddy's proxy routes traffic to ports, and since you've configured the ports in debugger version to be exactly same as in `docker-compose.yml` the calls will be arriving accordingly
  - The port that the service needs to listen to is defined in the `docker-compose.yml` - in the example below that port is 5511:

    ```yaml
        dockerCompose:
        services:
            config-service-proxy:
            ports:
                - 5511:5000
    ```

### Switching back to containers

Once you're done debugging and fixing your code you'll want to create a container with the latest code version for it. This means that instead of running the service in a debugger as a regular executable you will be running the latest version as a container again.

Please refer to [Running a component using source code, GitHub repository of a pre-built Docker image](./use-source-code-for-components.md) document to see how to update components definition file to instruct locally to build your component from the source code you have locally on your machine.

To build a brand new image for your service (based on the definition file - most likely from local source code) run the following command (pay attention to service and service component name in the command - these come from the service definition YAML file):

```bash
locally docker build config-service config-service-proxy
```

Once the image is created you can start the new service container by running

```bash
locally docker start config-service config-service-proxy
```
